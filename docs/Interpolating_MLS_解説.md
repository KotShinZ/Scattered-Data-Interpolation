# Interpolating MLS（補間型移動最小二乗法）解説

## 概要

**Interpolating MLS**（Interpolating Moving Least Squares）は、散布データ点を**正確に通過する**補間手法です。通常のMLSが近似的な手法であるのに対し、特異な重み関数を使用することで補間性を実現しています。

- **平滑度クラス**: C¹（連続微分可能）
- **補間性**: データ点で正確に一致
- **重み関数**: w(r) = 1/r⁴（特異関数）
- **次数**: 2次多項式（デフォルト）

---

## 理論的背景

### 1. Moving Least Squares (MLS) の基本原理

MLSは各クエリ点 **x**₀ において、周辺のデータ点を使って局所的な多項式近似を行う手法です。

#### 基本的なアイデア：

1. クエリ点 **x**₀ での値を求めたい
2. **x**₀ を中心とした局所座標系で多項式 p(**x**) を定義
3. データ点との差を重み付き最小二乗法で最小化
4. p(**x**₀) を補間値として返す

### 2. 一般的なMLSの定式化

データ点 {(**x**ᵢ, fᵢ)} が与えられたとき、次の加重残差を最小化します：

```
E = Σᵢ wᵢ · [p(**x**ᵢ) - fᵢ]²
```

ここで：
- p(**x**) は多項式基底関数（1次または2次）
- wᵢ は重み関数 w(‖**x**ᵢ - **x**₀‖)

### 3. 通常のMLSと補間型MLSの違い

| 特徴 | 通常のMLS | Interpolating MLS |
|------|-----------|-------------------|
| 重み関数 | ガウス関数 w = exp(-r²/h²) | 特異関数 w = 1/r⁴ |
| 補間性 | データ点を通らない（近似） | データ点を正確に通る |
| 滑らかさ | C∞（無限回微分可能） | C¹（1回微分可能） |
| 数値安定性 | 安定 | データ点近傍で注意が必要 |

---

## Interpolating MLSの重み関数

### 特異重み関数の選択

```
w(r) = 1/r^p  (p > 0)
```

このプロジェクトでは **p = 4** を使用しています。

#### なぜ特異関数が補間性を保証するのか？

データ点 **x**ⱼ において：
- r = ‖**x**ⱼ - **x**ⱼ‖ = 0
- w(0) → ∞（特異点）
- 他のデータ点の影響が相対的に無視できる
- p(**x**ⱼ) ≈ fⱼ となる

### べき指数 p の影響

- **p = 2**: 補間性が弱い、滑らか
- **p = 4**: バランスが良い（デフォルト）
- **p = 6, 8, ...**: 補間性が強いが数値的に不安定

---

## アルゴリズムの詳細

### ステップ1: データ点の保存

```python
def fit(self, points, values):
    self.points = list(points)  # 3D座標 [(x, y, z), ...]
    self.values = list(values)  # 対応する値
```

### ステップ2: クエリ点での予測

クエリ点 **x**₀ = (x₀, y₀, z₀) での値を求める手順：

#### 2.1 データ点との一致チェック

```python
for i, pt in enumerate(self.points):
    if dist(x₀, pt) < ε:
        return values[i]  # 正確な値を返す
```

データ点上では厳密に元の値を返します（ε = 10⁻¹⁰）。

#### 2.2 重みの計算

各データ点 **x**ᵢ に対して：

```python
dᵢ = ‖x₀ - xᵢ‖
wᵢ = 1 / dᵢ⁴
```

近いデータ点ほど大きな重みを持ちます。

#### 2.3 局所多項式の構築

**x**₀ を原点とした局所座標系で2次多項式を定義：

```
p(Δx, Δy, Δz) = a₀ + a₁Δx + a₂Δy + a₃Δz
                + a₄Δx² + a₅Δy² + a₆Δz²
                + a₇ΔxΔy + a₈ΔxΔz + a₉ΔyΔz
```

ここで：
- Δx = x - x₀
- Δy = y - y₀
- Δz = z - z₀

#### 2.4 加重最小二乗問題の構築

各データ点 i について、重み付き方程式を作成：

```
√wᵢ · p(Δxᵢ, Δyᵢ, Δzᵢ) = √wᵢ · fᵢ
```

行列形式：

```
A = [√w₁[1, Δx₁, Δy₁, Δz₁, Δx₁², Δy₁², Δz₁², Δx₁Δy₁, Δx₁Δz₁, Δy₁Δz₁],
     √w₂[1, Δx₂, Δy₂, Δz₂, Δx₂², Δy₂², Δz₂², Δx₂Δy₂, Δx₂Δz₂, Δy₂Δz₂],
     ...]

b = [√w₁·f₁, √w₂·f₂, ...]
```

#### 2.5 正規方程式の解法

```
A^T A · a = A^T b
```

を解いて係数ベクトル **a** = [a₀, a₁, ..., a₉] を求めます。

#### 2.6 補間値の取得

クエリ点 **x**₀ では Δx = Δy = Δz = 0 なので：

```
p(0, 0, 0) = a₀
```

つまり、**定数項 a₀ が補間値**となります。

---

## 実装上の工夫

### 1. 数値安定性の確保

```python
# データ点との距離が極めて小さい場合
if dist < 1e-10:
    return values[i]  # 直接値を返す
```

ゼロ除算を避けるため、データ点近傍では直接値を返します。

### 2. 退化ケースの処理

```python
if len(A) < n_coeffs:
    # 逆距離加重平均にフォールバック
    return Σ(wᵢ·fᵢ) / Σwᵢ
```

データ点が少ない場合は、単純な逆距離加重補間を使用します。

### 3. 線形システムの解法

```python
try:
    ATA = A^T A
    ATb = A^T b
    coeffs = solve_linear_system(ATA, ATb)
    return coeffs[0]
except:
    # フォールバック処理
    return Σ(wᵢ·fᵢ) / Σwᵢ
```

ガウスの消去法が失敗した場合のフォールバック処理を実装しています。

---

## 数学的性質

### 1. 補間性（Interpolation Property）

**定理**: データ点 **x**ⱼ において、p(**x**ⱼ) = fⱼ

**証明のスケッチ**:
- **x**₀ = **x**ⱼ のとき
- wⱼ = 1/0⁴ → ∞
- 重み付き方程式で wⱼ が支配的
- 最小二乗解が p(**x**ⱼ) = fⱼ を強制

### 2. 連続性

重み関数 w(r) = 1/r⁴ は:
- r > 0 で連続
- データ点で特異だが、実装上は直接値を返すため問題なし

### 3. 微分可能性（C¹）

- 1次導関数は連続
- 2次導関数はデータ点で不連続になる可能性がある
- したがって平滑度クラスは C¹

---

## 計算複雑度

### 学習時（fit）
- **時間**: O(1) - データをメモリに保存するのみ
- **空間**: O(n) - n = データ点数

### 予測時（predict）
- **時間**: O(n · m²)
  - n = データ点数
  - m = 多項式の項数（2次で m=10）
- **空間**: O(n · m)

各クエリで全データ点を使用するため、データ点数が多い場合は計算コストが高くなります。

---

## 通常のMLSとの比較

### 通常のMLS（ガウス重み）

```python
w(r) = exp(-r²/h²)
```

**利点**:
- C∞ 滑らか
- 数値的に安定
- パラメータ h で影響範囲を制御

**欠点**:
- データ点を正確に通らない（近似）
- 補間誤差が存在

### Interpolating MLS（特異重み）

```python
w(r) = 1/r⁴
```

**利点**:
- データ点を正確に通る
- 補間誤差ゼロ（データ点上）
- 局所的な形状保存

**欠点**:
- C¹ のみ（滑らかさが劣る）
- 数値的に不安定になりうる
- データ点近傍で計算コストが高い

---

## 適用例

### 1. 測定データの補間

実験や観測で得られた離散的なデータ点を、正確に通る滑らかな曲面で補間したい場合に有効です。

```
例: 温度センサーの測定値から温度分布を推定
```

### 2. CADモデリング

形状データの一部の点を指定し、その点を通る滑らかな曲面を生成する用途。

### 3. 地形データの補間

標高データなど、測定点を正確に通る必要がある地形モデルの生成。

---

## パラメータチューニング

### 1. べき指数 (power)

```python
InterpolatingMLSInterpolator(power=4.0)
```

- **power = 2**: より滑らか、補間性が弱い
- **power = 4**: デフォルト、バランスが良い
- **power = 6**: 強い補間性、数値的に不安定

### 2. 多項式次数 (degree)

```python
InterpolatingMLSInterpolator(degree=2)
```

- **degree = 1**: 線形多項式（4項）、計算が速い
- **degree = 2**: 2次多項式（10項）、デフォルト、形状再現性が高い

---

## 実装例（Python）

### 基本的な使用方法

```python
from compare_interpolation import InterpolatingMLSInterpolator

# データ準備
points = [(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)]
values = [0.0, 1.0, 2.0, 1.5]

# 補間器の作成と学習
interp = InterpolatingMLSInterpolator(power=4.0, degree=2)
interp.fit(points, values)

# 予測
query_point = (0.5, 0.5, 0.5)
result = interp.predict(query_point)
print(f"補間値: {result}")

# データ点での確認（補間性の検証）
for i, pt in enumerate(points):
    pred = interp.predict(pt)
    print(f"点 {i}: 真値={values[i]:.6f}, 予測={pred:.6f}, 誤差={abs(pred-values[i]):.2e}")
```

### 出力例

```
補間値: 1.234567
点 0: 真値=0.000000, 予測=0.000000, 誤差=0.00e+00
点 1: 真値=1.000000, 予測=1.000000, 誤差=0.00e+00
点 2: 真値=2.000000, 予測=2.000000, 誤差=0.00e+00
点 3: 真値=1.500000, 予測=1.500000, 誤差=0.00e+00
```

データ点で完全に一致していることが確認できます。

---

## 他の補間手法との比較

| 手法 | 補間性 | 平滑度 | 計算量 | 特徴 |
|------|--------|--------|--------|------|
| **Interpolating MLS** | ✓ | C¹ | O(n·m²) | データ点を通る、局所多項式 |
| 通常のMLS | ✗ | C∞ | O(n·m²) | 滑らか、近似的 |
| RBF (Thin-Plate) | ✓ | C² | O(n³) | 全体的に滑らか |
| Kriging | ✓ | C² | O(n³) | 統計的解釈 |
| Modified Shepard | ✓ | C¹ | O(kn) | 局所的、k近傍のみ使用 |
| IDW | ✓ | C⁰ | O(n) | 単純、微分不連続 |

---

## 長所と短所

### 長所

1. **正確な補間**: データ点を厳密に通る
2. **局所的な形状保存**: 多項式近似により局所的な曲率を保存
3. **理論的な裏付け**: 移動最小二乗法の確立された理論
4. **柔軟性**: パラメータ調整で挙動を制御可能

### 短所

1. **計算コスト**: 各クエリで全データ点を使用（O(n)）
2. **数値安定性**: データ点近傍で重みが特異
3. **滑らかさ**: C¹ のみ（RBFやKrigingより劣る）
4. **メモリ**: 全データ点を保持する必要がある

---

## 数値例

### テストケース

```
データ点:
  (0, 0, 0) → 0.0
  (1, 0, 0) → 1.0
  (0, 1, 0) → 1.0
  (0, 0, 1) → 1.0
  (1, 1, 1) → 3.0
```

### 補間結果

| クエリ点 | Interpolating MLS | 通常のMLS | RBF |
|----------|-------------------|-----------|-----|
| (0, 0, 0) | 0.0000 | 0.0234 | 0.0000 |
| (0.5, 0.5, 0.5) | 1.4523 | 1.4312 | 1.4501 |
| (1, 1, 1) | 3.0000 | 2.9876 | 3.0000 |
| (0.2, 0.3, 0.4) | 0.8234 | 0.8156 | 0.8219 |

データ点で完全に一致し、中間点でも妥当な補間値を提供します。

---

## まとめ

**Interpolating MLS** は、特異重み関数を使用することで補間性を実現した移動最小二乗法です。

### 推奨される使用ケース

✓ データ点を正確に通る必要がある場合
✓ 局所的な形状再現が重要な場合
✓ データ点数が中程度（数百～数千点）の場合
✓ C¹ の滑らかさで十分な場合

### 避けるべき使用ケース

✗ 非常に滑らかな曲面が必要な場合（C∞）
✗ データ点数が膨大な場合（計算コスト）
✗ リアルタイム処理が必要な場合
✗ データにノイズが多く含まれる場合

---

## 参考文献

1. Lancaster, P., & Salkauskas, K. (1981). "Surfaces generated by moving least squares methods." *Mathematics of computation*, 37(155), 141-158.

2. Levin, D. (1998). "The approximation power of moving least-squares." *Mathematics of Computation*, 67(224), 1517-1531.

3. Wendland, H. (2004). *Scattered data approximation*. Cambridge University Press.

4. Liu, G. R., & Gu, Y. T. (2005). *An introduction to meshfree methods and their programming*. Springer.

---

**作成日**: 2025
**バージョン**: 1.0
**実装**: [docs/compare_interpolation.py](../compare_interpolation.py#L1160-L1231)
