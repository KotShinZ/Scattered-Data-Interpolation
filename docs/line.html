<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>2軸固定ライン予測ビュー</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js" defer></script>
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

      :root {
        --bg-start: #fdfdfd;
        --bg-end: #edf2ff;
        --card-bg: rgba(255, 255, 255, 0.92);
        --card-border: rgba(15, 23, 42, 0.08);
        --text-main: #0f172a;
        --text-muted: rgba(15, 23, 42, 0.65);
        --accent: #2563eb;
        --accent-strong: #7c3aed;
        --shadow: 0 18px 55px rgba(15, 23, 42, 0.15);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top, rgba(221, 214, 254, 0.6), transparent 60%),
          linear-gradient(145deg, var(--bg-start), var(--bg-end));
        color: var(--text-main);
        padding: 2rem clamp(1rem, 4vw, 3rem) 4rem;
        font-family: 'Inter', 'Hiragino Sans', 'Yu Gothic', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      }

      .app-shell {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 2rem;
      }

      .hero-card {
        background: radial-gradient(circle at top right, rgba(37, 99, 235, 0.12), transparent 45%),
          var(--card-bg);
        border: 1px solid var(--card-border);
        border-radius: 32px;
        padding: clamp(1.5rem, 4vw, 2.75rem);
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 2rem;
        align-items: center;
        box-shadow: var(--shadow);
      }

      nav a {
        color: var(--accent);
        text-decoration: none;
        font-weight: 600;
      }

      h1 {
        margin: 0.4rem 0;
        font-size: clamp(1.8rem, 4vw, 2.5rem);
      }

      .hero-text p {
        margin: 0;
        color: var(--text-muted);
      }

      .hero-actions {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        align-items: flex-start;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 0.85rem 1.7rem;
        font-size: 1rem;
        font-weight: 600;
        background: linear-gradient(120deg, var(--accent), var(--accent-strong));
        color: #fff;
        cursor: pointer;
        box-shadow: 0 15px 40px rgba(124, 58, 237, 0.25);
        transition: transform 150ms ease, box-shadow 150ms ease;
      }

      button:hover:not([disabled]) {
        transform: translateY(-2px);
        box-shadow: 0 18px 45px rgba(37, 99, 235, 0.35);
      }

      button[disabled] {
        opacity: 0.6;
        cursor: progress;
        box-shadow: none;
      }

      #status {
        font-weight: 600;
        color: var(--text-muted);
      }

      .panel-grid {
        display: grid;
        gap: 1.5rem;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      .panel {
        background: var(--card-bg);
        border: 1px solid var(--card-border);
        border-radius: 28px;
        padding: 1.5rem;
        box-shadow: var(--shadow);
      }

      .panel h2 {
        margin-top: 0;
        margin-bottom: 0.4rem;
      }

      .panel p {
        margin-top: 0;
        color: var(--text-muted);
      }

      .control-stack {
        display: flex;
        flex-wrap: wrap;
        gap: 0.8rem;
        align-items: center;
      }

      label {
        font-weight: 600;
      }

      select,
      input[type='number'],
      input[type='file'] {
        background: rgba(15, 23, 42, 0.05);
        border: 1px solid rgba(15, 23, 42, 0.15);
        border-radius: 12px;
        padding: 0.65rem 0.9rem;
        color: var(--text-main);
        font-size: 1rem;
      }

      input[type='file'] {
        border-radius: 999px;
        background: rgba(37, 99, 235, 0.08);
      }

      input:disabled,
      select:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      #dataset-label {
        font-weight: 600;
        display: inline-block;
        margin-top: 0.4rem;
      }

      .fixed-grid {
        display: grid;
        gap: 1rem;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      }

      .point-range-grid {
        display: grid;
        gap: 0.8rem;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        margin-top: 0.75rem;
      }

      .point-range-grid label {
        font-size: 0.9rem;
        font-weight: 600;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .point-range-grid input {
        border-radius: 0.9rem;
        border: 1px solid rgba(15, 23, 42, 0.15);
        padding: 0.6rem 0.8rem;
        font-size: 0.95rem;
      }

      .range-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.8rem;
        margin-top: 0.75rem;
      }

      .range-grid label {
        font-size: 0.9rem;
        font-weight: 600;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .range-grid input {
        border-radius: 0.9rem;
        border: 1px solid rgba(15, 23, 42, 0.15);
        padding: 0.6rem 0.8rem;
        font-size: 0.95rem;
      }

      .range-actions {
        display: flex;
        gap: 0.75rem;
        justify-content: flex-start;
        align-items: center;
        margin-top: 0.5rem;
      }

      .settings-cta {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .cta-row {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
      }

      .cta-hint {
        color: var(--text-muted);
        font-size: 0.95rem;
      }

      .modal-section {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .fixed-control {
        border-radius: 20px;
        border: 1px solid rgba(15, 23, 42, 0.08);
        padding: 1rem;
        background: rgba(255, 255, 255, 0.85);
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        transition: transform 150ms ease, border-color 150ms ease;
        box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08);
      }

      .fixed-control.disabled {
        opacity: 0.5;
      }

      .fixed-control:hover {
        transform: translateY(-2px);
        border-color: rgba(37, 99, 235, 0.35);
      }

      .resolution-box {
        margin-top: 1.2rem;
        padding: 1rem;
        border-radius: 20px;
        border: 1px solid rgba(15, 23, 42, 0.08);
        background: rgba(255, 255, 255, 0.9);
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08);
      }

      .resolution-box label {
        font-weight: 600;
      }

      .resolution-box input {
        max-width: 200px;
      }

      .resolution-box p {
        margin: 0;
        color: var(--text-muted);
        font-size: 0.9rem;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 22px;
        overflow: hidden;
        box-shadow: 0 15px 40px rgba(15, 23, 42, 0.1);
      }

      th,
      td {
        padding: 0.85rem;
        text-align: center;
        border-bottom: 1px solid rgba(15, 23, 42, 0.08);
        font-variant-numeric: tabular-nums;
      }

      thead {
        background: rgba(99, 102, 241, 0.1);
      }

      tbody tr:last-child td {
        border-bottom: none;
      }

      #plots-container {
        margin-top: 0.5rem;
        display: grid;
        gap: 1.5rem;
      }

      @media (min-width: 960px) {
        #plots-container {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }

      .plot-card {
        background: rgba(249, 250, 255, 0.95);
        border-radius: 22px;
        border: 1px solid rgba(15, 23, 42, 0.08);
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
        box-shadow: 0 15px 40px rgba(15, 23, 42, 0.12);
      }

      .plot-card header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.8rem;
      }

      .plot-card header h3,
      .plot-title-button {
        margin: 0;
        cursor: pointer;
        transition: color 0.2s ease, transform 0.2s ease;
      }

      .plot-card header h3:hover,
      .plot-card header h3:focus-visible,
      .plot-title-button:hover,
      .plot-title-button:focus-visible {
        color: var(--accent);
        outline: none;
        transform: translateY(-1px);
      }

      .plot-container {
        width: 100%;
        height: 320px;
        border-radius: 16px;
      }

      .skipped {
        margin-top: 1rem;
        background: rgba(250, 204, 21, 0.18);
        border: 1px solid rgba(250, 204, 21, 0.4);
        border-radius: 18px;
        padding: 1rem;
        color: #92400e;
        font-weight: 600;
      }

      .hint-box {
        margin-top: 0.8rem;
        padding: 0.85rem 1rem;
        border-radius: 18px;
        background: rgba(226, 232, 240, 0.7);
        color: var(--text-muted);
      }

      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.45);
        z-index: 90;
        display: none;
        backdrop-filter: blur(2px);
      }

      .modal-backdrop.open {
        display: block;
      }

      .modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 95;
        padding: 2rem;
      }

      .modal.open {
        display: flex;
      }

      .modal-content {
        width: min(1200px, 95vw);
        height: min(85vh, 720px);
        background: rgba(255, 255, 255, 0.98);
        border-radius: 32px;
        border: 1px solid rgba(15, 23, 42, 0.12);
        box-shadow: 0 25px 90px rgba(15, 23, 42, 0.25);
        padding: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .modal header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      .modal h3 {
        margin: 0;
      }

      .modal-close {
        align-self: flex-start;
        background: rgba(37, 99, 235, 0.15);
        border-radius: 999px;
        padding: 0.45rem 1.2rem;
        font-size: 0.9rem;
        color: var(--text-main);
      }

      .modal-range-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 0.8rem;
      }

      .modal-range-grid label {
        font-size: 0.85rem;
        font-weight: 600;
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }

      .modal-range-grid input {
        border-radius: 0.9rem;
        border: 1px solid rgba(15, 23, 42, 0.15);
        padding: 0.55rem 0.75rem;
        font-size: 0.95rem;
      }

      .modal-range-actions {
        display: flex;
        justify-content: flex-end;
      }

      .modal-range-actions button {
        border-radius: 999px;
        padding: 0.4rem 1.2rem;
        font-size: 0.85rem;
        background: rgba(15, 23, 42, 0.08);
        color: var(--text-main);
      }

      #modal-plot {
        flex: 1;
      }

      a {
        color: var(--accent);
      }

      code {
        font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <header class="hero-card">
        <div class="hero-text">
          <nav><a href="index.html">↩ 平面サーフェスビューへ戻る</a></nav>
          <h1>2軸固定ラインビュー</h1>
          <p>固定した平面上で 1 次元の切片を抽出し、各補間手法の振る舞いを折れ線で比較します。</p>
        </div>
        <div class="hero-actions">
          <button id="run-button">ラインを計算</button>
          <p id="status">Pyodideを初期化中...</p>
        </div>
      </header>

      <section class="panel-grid">
        <article class="panel">
          <h2>データソース</h2>
          <p>メインビューと同じ学習データを利用します。読み込むと自動で学習が走り、保存済みのCSVはどちらのページでも再利用できます。</p>
          <div class="control-stack" id="dataset-controls">
            <label for="csv-input">CSVをインポート:</label>
            <input id="csv-input" type="file" accept=".csv,text/csv" />
            <button id="reset-dataset" type="button">ダミーデータを使用</button>
            <button id="use-saved-dataset" type="button" hidden>保存済みデータを読み込む</button>
          </div>
          <span id="dataset-label">現在: データ未読み込み</span>
          <div class="hint-box">
            CSV には <code>x,y,z,value</code> の 4 列を含めてください。読み込み完了後に学習し、ボタン押下で predict のみを実行します。
          </div>
        </article>

        <article class="panel settings-cta">
          <h2>詳細設定</h2>
          <p>
            ライン設定・表示レンジ・元データ表示範囲は、下のボタンから開く設定ウインドウでまとめて調整できます。
          </p>
          <div class="cta-row">
            <button id="open-line-settings" type="button">詳細設定を開く</button>
            <span class="cta-hint">設定変更は再学習なしで反映されます。</span>
          </div>
        </article>
      </section>

      <section class="panel">
        <h2>評価指標とラインチャート</h2>
        <p>メインビューと同じ RMSE / 滑らかさ指標に加え、各補間手法の 1 次元スライスを折れ線と元データ散布で重ねます。</p>
        <table id="results-table" aria-live="polite">
          <thead>
            <tr>
              <th>手法</th>
              <th>滑らかさクラス</th>
              <th>RMSE</th>
              <th>勾配滑らかさ</th>
              <th>ラプラシアン滑らかさ</th>
            </tr>
          </thead>
          <tbody>
            <tr><td colspan="5">結果はまだ計算されていません。</td></tr>
          </tbody>
        </table>
        <div id="plots-container" aria-live="polite">ラインチャートは結果計算後に表示されます。</div>
        <div id="skipped" class="skipped" hidden></div>
      </section>
    </div>

    <div class="modal-backdrop" id="line-settings-backdrop"></div>
    <div class="modal" id="line-settings-modal" aria-hidden="true">
      <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="line-settings-title">
        <header>
          <h3 id="line-settings-title">詳細設定</h3>
          <button type="button" class="modal-close" id="line-settings-close">閉じる</button>
        </header>

        <section class="modal-section">
          <h4>元データ表示範囲</h4>
          <p>
            折れ線グラフと拡大ビューに重ねる元データの散布点を、指定した X/Y/Z の最小値・最大値で絞り込みます。
            データ読み込み時に自動値がセットされ、入力を変更すると即座に反映されます。
          </p>
          <div class="point-range-grid">
            <label>
              <span>X 最小値</span>
              <input id="point-range-x-min" type="number" step="any" />
            </label>
            <label>
              <span>X 最大値</span>
              <input id="point-range-x-max" type="number" step="any" />
            </label>
            <label>
              <span>Y 最小値</span>
              <input id="point-range-y-min" type="number" step="any" />
            </label>
            <label>
              <span>Y 最大値</span>
              <input id="point-range-y-max" type="number" step="any" />
            </label>
            <label>
              <span>Z 最小値</span>
              <input id="point-range-z-min" type="number" step="any" />
            </label>
            <label>
              <span>Z 最大値</span>
              <input id="point-range-z-max" type="number" step="any" />
            </label>
          </div>
          <div class="hint-box">
            入力を空欄にすると自動設定の値に戻ります。サーフェスビューと同様に、再学習なしで散布点の表示だけを切り替えられます。
          </div>
        </section>

        <section class="modal-section">
          <h4>ライン設定</h4>
          <p>変化させたい軸と、残り 2 軸の固定値、ライン解像度をまとめて設定できます。</p>
          <div class="control-stack">
            <label for="line-axis">変化させる軸:</label>
            <select id="line-axis">
              <option value="x">X 軸</option>
              <option value="y">Y 軸</option>
              <option value="z" selected>Z 軸</option>
            </select>
          </div>
          <div class="fixed-grid">
            <label class="fixed-control" data-axis="x">
              <span>X 軸の固定値</span>
              <input id="fixed-x" type="number" step="any" value="0.5" />
            </label>
            <label class="fixed-control" data-axis="y">
              <span>Y 軸の固定値</span>
              <input id="fixed-y" type="number" step="any" value="0.5" />
            </label>
            <label class="fixed-control" data-axis="z">
              <span>Z 軸の固定値</span>
              <input id="fixed-z" type="number" step="any" value="0.5" />
            </label>
          </div>
          <div class="resolution-box">
            <label for="line-resolution">ライン解像度（サンプル数）</label>
            <input
              id="line-resolution"
              type="number"
              step="10"
              min="10"
              max="2000"
              value="60"
            />
            <p>
              大きな値にすると折れ線が滑らかになります（最大 2000）。値を下げると計算は速くなります。
            </p>
          </div>
        </section>

        <section class="modal-section">
          <h4>表示レンジとズーム</h4>
          <p>表示範囲を手動で指定したり、拡大ビューで詳細を確認できます。未入力の軸は自動スケールになります。</p>
          <div class="range-grid">
            <label class="range-input">
              <span>X 軸の最小値</span>
              <input id="x-range-min" type="number" step="any" placeholder="自動" />
            </label>
            <label class="range-input">
              <span>X 軸の最大値</span>
              <input id="x-range-max" type="number" step="any" placeholder="自動" />
            </label>
            <label class="range-input">
              <span>Y 軸の最小値</span>
              <input id="y-range-min" type="number" step="any" placeholder="自動" />
            </label>
            <label class="range-input">
              <span>Y 軸の最大値</span>
              <input id="y-range-max" type="number" step="any" placeholder="自動" />
            </label>
          </div>
          <div class="range-actions">
            <button id="apply-range" type="button">表示範囲を適用</button>
            <button id="reset-range" type="button">リセット</button>
          </div>
        </section>
      </div>
    </div>

    <div class="modal-backdrop" id="modal-backdrop"></div>
    <div class="modal" id="plot-modal" aria-hidden="true">
      <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="modal-title">
        <header>
          <h3 id="modal-title">拡大表示</h3>
          <button type="button" class="modal-close" id="modal-close">閉じる</button>
        </header>
        <div class="modal-range-grid">
          <label>
            <span id="modal-x-label-min">横軸 最小</span>
            <input type="number" id="modal-x-min" step="any" placeholder="自動" />
          </label>
          <label>
            <span id="modal-x-label-max">横軸 最大</span>
            <input type="number" id="modal-x-max" step="any" placeholder="自動" />
          </label>
          <label>
            <span id="modal-y-label-min">縦軸 最小</span>
            <input type="number" id="modal-y-min" step="any" placeholder="自動" />
          </label>
          <label>
            <span id="modal-y-label-max">縦軸 最大</span>
            <input type="number" id="modal-y-max" step="any" placeholder="自動" />
          </label>
        </div>
        <div class="modal-range-actions">
          <button type="button" id="modal-range-reset">入力をクリア</button>
        </div>
        <div id="modal-plot"></div>
      </div>
    </div>

    <script src="dataset-store.js"></script>
    <script>
      const datasetStore = window.datasetStore || null;
      const DEFAULT_DUMMY_BOUNDS = [
        [0, 1],
        [0, 1],
        [0, 1],
      ];
      const statusEl = document.getElementById("status");
      const buttonEl = document.getElementById("run-button");
      const tableBody = document.querySelector("#results-table tbody");
      const plotsContainer = document.getElementById("plots-container");
      const skippedContainer = document.getElementById("skipped");
      const lineAxisSelect = document.getElementById("line-axis");
      const lineResolutionInput = document.getElementById("line-resolution");
      const fixedInputs = {
        x: document.getElementById("fixed-x"),
        y: document.getElementById("fixed-y"),
        z: document.getElementById("fixed-z"),
      };
      const datasetLabel = document.getElementById("dataset-label");
      const useSavedDatasetButton = document.getElementById("use-saved-dataset");
      const fileInput = document.getElementById("csv-input");
      const resetDatasetButton = document.getElementById("reset-dataset");
      const pointRangeInputs = {
        x: {
          min: document.getElementById("point-range-x-min"),
          max: document.getElementById("point-range-x-max"),
        },
        y: {
          min: document.getElementById("point-range-y-min"),
          max: document.getElementById("point-range-y-max"),
        },
        z: {
          min: document.getElementById("point-range-z-min"),
          max: document.getElementById("point-range-z-max"),
        },
      };
      const rangeInputs = {
        xMin: document.getElementById("x-range-min"),
        xMax: document.getElementById("x-range-max"),
        yMin: document.getElementById("y-range-min"),
        yMax: document.getElementById("y-range-max"),
      };
      const rangeApplyButton = document.getElementById("apply-range");
      const rangeResetButton = document.getElementById("reset-range");
      const modalBackdrop = document.getElementById("modal-backdrop");
      const plotModal = document.getElementById("plot-modal");
      const modalPlotEl = document.getElementById("modal-plot");
      const modalTitleEl = document.getElementById("modal-title");
      const modalCloseButton = document.getElementById("modal-close");
      const modalXAxisMin = document.getElementById("modal-x-min");
      const modalXAxisMax = document.getElementById("modal-x-max");
      const modalYAxisMin = document.getElementById("modal-y-min");
      const modalYAxisMax = document.getElementById("modal-y-max");
      const modalXAxisLabelMin = document.getElementById("modal-x-label-min");
      const modalXAxisLabelMax = document.getElementById("modal-x-label-max");
      const modalYAxisLabelMin = document.getElementById("modal-y-label-min");
      const modalYAxisLabelMax = document.getElementById("modal-y-label-max");
      const modalRangeResetButton = document.getElementById("modal-range-reset");
      const lineSettingsBackdrop = document.getElementById("line-settings-backdrop");
      const lineSettingsModal = document.getElementById("line-settings-modal");
      const lineSettingsOpenButton = document.getElementById("open-line-settings");
      const lineSettingsCloseButton = document.getElementById("line-settings-close");

      if (buttonEl) {
        buttonEl.disabled = true;
      }

      let latestSummaries = [];
      let latestLineResults = [];
      let latestDataset = null;
      let importedDataset = null;
      let importedDatasetName = "";
      let sessionReady = false;
      let trainingPromise = null;
      let predicting = false;
      let datasetSource = "none";
      const axisKeys = ["x", "y", "z"];
      let defaultPointRange = null;
      let currentPointRange = null;
      let pointRangeDirty = false;

      let storedSelection = datasetStore ? datasetStore.load() : null;
      const manualAxisRanges = {
        x: { min: null, max: null },
        y: { min: null, max: null },
      };
      let modalContext = null;
      const DEFAULT_LINE_RESOLUTION = 60;
      const LINE_RESOLUTION_LIMITS = { min: 10, max: 2000 };
      const plotlyConfig = {
        responsive: true,
        displaylogo: false,
        modeBarButtonsToRemove: ["toImage"],
        scrollZoom: true,
      };

      setAxisControlsDisabled(true);
      syncRangeInputsFromState();
      if (lineResolutionInput) {
        lineResolutionInput.value = String(DEFAULT_LINE_RESOLUTION);
        const ensureBounds = () => {
          sanitizeLineResolutionInput();
        };
        lineResolutionInput.addEventListener("change", ensureBounds);
        lineResolutionInput.addEventListener("blur", ensureBounds);
        lineResolutionInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            sanitizeLineResolutionInput();
            runLinePrediction();
          }
        });
      }

      if (rangeApplyButton) {
        rangeApplyButton.addEventListener("click", applyAxisRangeSettings);
      }
      if (rangeResetButton) {
        rangeResetButton.addEventListener("click", handleRangeReset);
      }
      Object.values(rangeInputs).forEach((input) => {
        if (!input) {
          return;
        }
        input.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            applyAxisRangeSettings();
          }
        });
      });

      function currentDatasetLabel() {
        if (datasetSource === "custom") {
          return importedDatasetName || "インポートデータ";
        }
        if (datasetSource === "dummy") {
          return "ダミーデータ";
        }
        return "データ未読み込み";
      }

      function updateDatasetLabel() {
        if (!datasetLabel) {
          return;
        }
        if (datasetSource === "custom") {
          datasetLabel.textContent = `現在: ${
            importedDatasetName || "インポートデータ"
          } を使用`;
        } else if (datasetSource === "dummy") {
          datasetLabel.textContent = "現在: ダミーデータを使用";
        } else {
          datasetLabel.textContent = "現在: データ未読み込み";
        }
      }

      function refreshStoredDatasetButton() {
        if (!useSavedDatasetButton) {
          return;
        }
        const hasStored = storedSelection && storedSelection.dataset;
        useSavedDatasetButton.hidden = !hasStored;
        if (hasStored) {
          const label = storedSelection.name || "インポートデータ";
          useSavedDatasetButton.textContent = `${label} を読み込む`;
        }
      }

      function parseRangeInputValue(input) {
        if (!input) {
          return null;
        }
        const trimmed = (input.value || "").trim();
        if (!trimmed) {
          return null;
        }
        const parsed = Number.parseFloat(trimmed);
        return Number.isFinite(parsed) ? parsed : null;
      }

      function syncRangeInputsFromState() {
        if (rangeInputs.xMin) {
          rangeInputs.xMin.value = manualAxisRanges.x.min ?? "";
        }
        if (rangeInputs.xMax) {
          rangeInputs.xMax.value = manualAxisRanges.x.max ?? "";
        }
        if (rangeInputs.yMin) {
          rangeInputs.yMin.value = manualAxisRanges.y.min ?? "";
        }
        if (rangeInputs.yMax) {
          rangeInputs.yMax.value = manualAxisRanges.y.max ?? "";
        }
      }

      function updateManualAxisRangesFromInputs() {
        manualAxisRanges.x.min = parseRangeInputValue(rangeInputs.xMin);
        manualAxisRanges.x.max = parseRangeInputValue(rangeInputs.xMax);
        manualAxisRanges.y.min = parseRangeInputValue(rangeInputs.yMin);
        manualAxisRanges.y.max = parseRangeInputValue(rangeInputs.yMax);
      }

      function resetAxisRanges() {
        manualAxisRanges.x.min = null;
        manualAxisRanges.x.max = null;
        manualAxisRanges.y.min = null;
        manualAxisRanges.y.max = null;
        syncRangeInputsFromState();
      }

      function applyAxisRangeSettings() {
        updateManualAxisRangesFromInputs();
        renderLinePlots(latestLineResults);
      }

      function handleRangeReset() {
        resetAxisRanges();
        renderLinePlots(latestLineResults);
      }

      function filterFinite(values) {
        if (!Array.isArray(values)) {
          return [];
        }
        return values
          .map((value) => Number.parseFloat(value))
          .filter((value) => Number.isFinite(value));
      }

      function cloneRange(range) {
        if (!range) {
          return null;
        }
        const copy = {};
        axisKeys.forEach((axis) => {
          if (range[axis]) {
            copy[axis] = {
              min: Number(range[axis].min),
              max: Number(range[axis].max),
            };
          }
        });
        return copy;
      }

      function rangeFromAxisBounds(bounds) {
        if (!Array.isArray(bounds) || bounds.length < 3) {
          return null;
        }
        const range = {};
        axisKeys.forEach((axis, index) => {
          const pair = bounds[index];
          if (!Array.isArray(pair) || pair.length < 2) {
            return;
          }
          const min = Number(pair[0]);
          const max = Number(pair[1]);
          if (Number.isFinite(min) && Number.isFinite(max)) {
            range[axis] = { min, max };
          }
        });
        return Object.keys(range).length === axisKeys.length ? range : null;
      }

      function rangeFromPoints(points) {
        if (!Array.isArray(points) || !points.length) {
          return null;
        }
        const stats = axisKeys.map(() => ({ min: Infinity, max: -Infinity }));
        points.forEach((point) => {
          if (!Array.isArray(point) || point.length < 3) {
            return;
          }
          point.forEach((value, idx) => {
            const numeric = Number(value);
            if (!Number.isFinite(numeric)) {
              return;
            }
            if (numeric < stats[idx].min) {
              stats[idx].min = numeric;
            }
            if (numeric > stats[idx].max) {
              stats[idx].max = numeric;
            }
          });
        });
        if (stats.some((item) => !Number.isFinite(item.min) || !Number.isFinite(item.max))) {
          return null;
        }
        const range = {};
        axisKeys.forEach((axis, index) => {
          range[axis] = {
            min: stats[index].min,
            max: stats[index].max,
          };
        });
        return range;
      }

      function deriveRangeFromDataset(dataset) {
        if (!dataset || typeof dataset !== "object") {
          return null;
        }
        const fromBounds = rangeFromAxisBounds(dataset.axis_bounds);
        if (fromBounds) {
          return fromBounds;
        }
        if (Array.isArray(dataset.points)) {
          return rangeFromPoints(dataset.points);
        }
        return null;
      }

      function applyPointRangeInputs(range) {
        axisKeys.forEach((axis) => {
          const controls = pointRangeInputs[axis];
          if (!controls) {
            return;
          }
          const axisRange = range && range[axis];
          if (!axisRange) {
            if (controls.min) {
              controls.min.value = "";
            }
            if (controls.max) {
              controls.max.value = "";
            }
            return;
          }
          if (controls.min) {
            controls.min.value = Number(axisRange.min).toFixed(4);
          }
          if (controls.max) {
            controls.max.value = Number(axisRange.max).toFixed(4);
          }
        });
      }

      function setPointRangeFromDataset(datasetLike, options = {}) {
        const candidate = deriveRangeFromDataset(datasetLike);
        if (!candidate) {
          return;
        }
        defaultPointRange = cloneRange(candidate);
        if (options.force || !pointRangeDirty) {
          currentPointRange = cloneRange(candidate);
          pointRangeDirty = false;
          applyPointRangeInputs(currentPointRange);
          rerenderPlotsForPointRange();
        }
      }

      function getActivePointRange() {
        return currentPointRange || defaultPointRange;
      }

      function readPointRangeInputs() {
        const range = {};
        let valid = true;
        axisKeys.forEach((axis) => {
          const controls = pointRangeInputs[axis];
          if (!controls) {
            return;
          }
          const rawMin = controls.min ? Number.parseFloat(controls.min.value) : NaN;
          const rawMax = controls.max ? Number.parseFloat(controls.max.value) : NaN;
          let min = Number.isFinite(rawMin)
            ? rawMin
            : currentPointRange?.[axis]?.min ?? defaultPointRange?.[axis]?.min;
          let max = Number.isFinite(rawMax)
            ? rawMax
            : currentPointRange?.[axis]?.max ?? defaultPointRange?.[axis]?.max;
          if (!Number.isFinite(min) || !Number.isFinite(max)) {
            valid = false;
            return;
          }
          if (min > max) {
            valid = false;
            return;
          }
          range[axis] = { min, max };
        });
        return valid ? range : null;
      }

      function pointWithinRange(point, range) {
        if (!range) {
          return true;
        }
        for (let index = 0; index < axisKeys.length; index += 1) {
          const axis = axisKeys[index];
          const axisRange = range[axis];
          if (!axisRange) {
            continue;
          }
          const coordinate = Number(point[index]);
          if (!Number.isFinite(coordinate)) {
            return false;
          }
          if (Number.isFinite(axisRange.min) && coordinate < axisRange.min) {
            return false;
          }
          if (Number.isFinite(axisRange.max) && coordinate > axisRange.max) {
            return false;
          }
        }
        return true;
      }

      function filterDatasetForDisplay(dataset) {
        const range = getActivePointRange();
        if (
          !range ||
          !dataset ||
          typeof dataset !== "object" ||
          !Array.isArray(dataset.points) ||
          !Array.isArray(dataset.values)
        ) {
          return dataset;
        }
        const filteredPoints = [];
        const filteredValues = [];
        dataset.points.forEach((point, index) => {
          if (!Array.isArray(point) || point.length < 3) {
            return;
          }
          const numericPoint = point.map((value) => Number(value));
          if (numericPoint.some((value) => !Number.isFinite(value))) {
            return;
          }
          const numericValue = Number(dataset.values[index]);
          if (!Number.isFinite(numericValue)) {
            return;
          }
          if (pointWithinRange(numericPoint, range)) {
            filteredPoints.push(numericPoint);
            filteredValues.push(numericValue);
          }
        });
        return {
          points: filteredPoints,
          values: filteredValues,
          axis_bounds: dataset.axis_bounds,
          source: dataset.source,
        };
      }

      function rerenderPlotsForPointRange() {
        if (!latestLineResults.length || !latestDataset) {
          return;
        }
        renderLinePlots(latestLineResults);
      }

      function handlePointRangeInput() {
        pointRangeDirty = true;
        const range = readPointRangeInputs();
        if (!range) {
          return;
        }
        currentPointRange = range;
        rerenderPlotsForPointRange();
      }

      function computeAxisRange(manualRange, fallbackValues) {
        const finiteValues = filterFinite(fallbackValues || []);
        const hasManualMin = Number.isFinite(manualRange.min);
        const hasManualMax = Number.isFinite(manualRange.max);
        if (hasManualMin && hasManualMax) {
          return [manualRange.min, manualRange.max];
        }
        if (!finiteValues.length) {
          return null;
        }
        const fallbackMin = Math.min(...finiteValues);
        const fallbackMax = Math.max(...finiteValues);
        const resolvedMin = hasManualMin ? manualRange.min : fallbackMin;
        const resolvedMax = hasManualMax ? manualRange.max : fallbackMax;
        if (Number.isFinite(resolvedMin) && Number.isFinite(resolvedMax)) {
          return [resolvedMin, resolvedMax];
        }
        return null;
      }

      function applyAxisRangesToLayout(layout, item, datasetForDisplay) {
        if (!layout || !item) {
          return;
        }
        layout.xaxis = layout.xaxis || {};
        layout.yaxis = layout.yaxis || {};
        const xRange = computeAxisRange(manualAxisRanges.x, item.axis_values || []);
        if (xRange) {
          layout.xaxis.range = xRange;
          layout.xaxis.autorange = false;
        } else {
          delete layout.xaxis.range;
          layout.xaxis.autorange = true;
        }
        const datasetValues = Array.isArray(datasetForDisplay?.values)
          ? datasetForDisplay.values
          : [];
        const yRange = computeAxisRange(
          manualAxisRanges.y,
          (item.predicted_values || []).concat(datasetValues)
        );
        if (yRange) {
          layout.yaxis.range = yRange;
          layout.yaxis.autorange = false;
        } else {
          delete layout.yaxis.range;
          layout.yaxis.autorange = true;
        }
      }

      function cloneTraces(traces) {
        if (!Array.isArray(traces)) {
          return [];
        }
        return traces.map((trace) => JSON.parse(JSON.stringify(trace)));
      }

      function clearVisualizations() {
        latestSummaries = [];
        latestLineResults = [];
        latestDataset = null;
        renderTableRows([]);
        resetAxisRanges();
        if (plotsContainer) {
          plotsContainer.textContent = "ラインプロットは結果計算後に表示されます。";
        }
        if (skippedContainer) {
          skippedContainer.hidden = true;
          skippedContainer.textContent = "";
        }
      }

      function setAxisControlsDisabled(disabled) {
        if (lineAxisSelect) {
          lineAxisSelect.disabled = disabled;
        }
        if (disabled) {
          Object.values(fixedInputs).forEach((input) => {
            if (input) {
              input.disabled = true;
            }
          });
        } else {
          updateFixedControlsState();
        }
      }

      function updateFixedControlsState() {
        const varying = (lineAxisSelect ? lineAxisSelect.value : "z") || "z";
        Object.entries(fixedInputs).forEach(([axis, input]) => {
          if (!input) {
            return;
          }
          const parent = input.closest(".fixed-control");
          const disable = axis === varying.toLowerCase();
          input.disabled = disable;
          if (parent) {
            parent.classList.toggle("disabled", disable);
          }
        });
      }

      function sanitizeLineResolutionInput() {
        if (!lineResolutionInput) {
          return;
        }
        let parsed = Number.parseInt(lineResolutionInput.value, 10);
        if (!Number.isFinite(parsed)) {
          lineResolutionInput.value = String(DEFAULT_LINE_RESOLUTION);
          return;
        }
        parsed = Math.min(
          Math.max(parsed, LINE_RESOLUTION_LIMITS.min),
          LINE_RESOLUTION_LIMITS.max
        );
        lineResolutionInput.value = String(parsed);
      }

      function getLineResolutionPayload() {
        if (!lineResolutionInput) {
          return null;
        }
        const parsed = Number.parseInt(lineResolutionInput.value, 10);
        if (!Number.isFinite(parsed)) {
          return null;
        }
        return Math.min(
          Math.max(parsed, LINE_RESOLUTION_LIMITS.min),
          LINE_RESOLUTION_LIMITS.max
        );
      }

      function setFixedDefaultsFromBounds(bounds) {
        if (!Array.isArray(bounds)) {
          return;
        }
        ["x", "y", "z"].forEach((axis, index) => {
          const input = fixedInputs[axis];
          if (!input) {
            return;
          }
          const entry = bounds[index];
          if (!Array.isArray(entry) || entry.length < 2) {
            return;
          }
          const minValue = Number(entry[0]);
          const maxValue = Number(entry[1]);
          if (!Number.isFinite(minValue) || !Number.isFinite(maxValue)) {
            return;
          }
          const midpoint = (minValue + maxValue) / 2;
          const current = Number.parseFloat(input.value);
          if (!Number.isFinite(current)) {
            input.value = String(midpoint);
          }
        });
      }

      function applyFixedAxesFromResult(fixedMap) {
        if (!fixedMap || typeof fixedMap !== "object") {
          return;
        }
        Object.entries(fixedInputs).forEach(([axis, input]) => {
          if (!input) {
            return;
          }
          const rawValue = fixedMap[axis];
          const numericValue = Number(rawValue);
          if (Number.isFinite(numericValue)) {
            input.value = String(numericValue);
          }
        });
      }

      function parseCsvDataset(text) {
        const lines = text
          .split(/\r?\n/)
          .map((line) => line.trim())
          .filter((line) => line.length > 0);
        if (!lines.length) {
          throw new Error("CSVに有効なデータ行がありません。");
        }

        let startIndex = 0;
        let columnOrder = [0, 1, 2, 3];
        const firstCells = lines[0].split(",").map((cell) => cell.trim());
        const lowerHeader = firstCells.map((cell) => cell.toLowerCase());
        const hasHeader =
          lowerHeader.includes("x") ||
          lowerHeader.includes("y") ||
          lowerHeader.includes("z") ||
          lowerHeader.includes("value");

        if (hasHeader) {
          const required = ["x", "y", "z", "value"];
          columnOrder = required.map((key) => {
            const index = lowerHeader.indexOf(key);
            if (index === -1) {
              throw new Error("ヘッダーには x, y, z, value の列が必要です。");
            }
            return index;
          });
          startIndex = 1;
        } else if (firstCells.length < 4) {
          throw new Error("各行には少なくとも4列の数値が必要です。");
        }

        const points = [];
        const values = [];
        for (let rowIndex = startIndex; rowIndex < lines.length; rowIndex += 1) {
          const row = lines[rowIndex];
          if (!row) {
            continue;
          }
          const cells = row.split(",").map((cell) => cell.trim());
          if (cells.length < 4) {
            throw new Error(`行 ${rowIndex + 1} に十分な列がありません。`);
          }
          const pick = (index) => {
            if (index >= cells.length) {
              throw new Error(`行 ${rowIndex + 1} の列数が足りません。`);
            }
            return cells[index];
          };
          const x = Number(pick(columnOrder[0]));
          const y = Number(pick(columnOrder[1]));
          const z = Number(pick(columnOrder[2]));
          const value = Number(pick(columnOrder[3]));
          if (
            !Number.isFinite(x) ||
            !Number.isFinite(y) ||
            !Number.isFinite(z) ||
            !Number.isFinite(value)
          ) {
            throw new Error(`行 ${rowIndex + 1} に数値以外の値が含まれています。`);
          }
          points.push([x, y, z]);
          values.push(value);
        }

        if (!points.length) {
          throw new Error("CSVに有効なデータ行がありません。");
        }

        return { points, values };
      }

      refreshStoredDatasetButton();
      updateDatasetLabel();
      updateFixedControlsState();
      clearVisualizations();

      const worker = new Worker("pyodide-worker.js");
      let workerRequestId = 0;
      const workerRequests = new Map();

      function callWorker(type, payload) {
        return new Promise((resolve, reject) => {
          const id = ++workerRequestId;
          workerRequests.set(id, { resolve, reject });
          worker.postMessage({ id, type, payload });
        });
      }

      worker.addEventListener("message", (event) => {
        const data = event.data || {};
        if (data.type === "status" && data.message) {
          statusEl.textContent = data.message;
          return;
        }
        if (!data.id) {
          return;
        }
        const entry = workerRequests.get(data.id);
        if (!entry) {
          return;
        }
        workerRequests.delete(data.id);
        if (data.error) {
          const error = new Error(data.error.message || "ワーカーエラーが発生しました");
          if (data.error.stack) {
            error.stack = data.error.stack;
          }
          entry.reject(error);
        } else {
          entry.resolve(data.result);
        }
      });

      worker.addEventListener("error", (event) => {
        console.error(event);
        statusEl.textContent = "Pyodideワーカーでエラーが発生しました";
        if (buttonEl) {
          buttonEl.disabled = true;
        }
      });

      const pyodideReadyPromise = callWorker("init")
        .then(() => {
          statusEl.textContent = "準備完了。まずデータを読み込んで学習してください。";
        })
        .catch((error) => {
          const message = error && error.message ? error.message : String(error);
          statusEl.textContent = "初期化に失敗しました: " + message;
          if (buttonEl) {
            buttonEl.disabled = true;
          }
          throw error;
        });

      if (fileInput) {
        fileInput.addEventListener("change", async (event) => {
          const target = event.target;
          const file = target && target.files ? target.files[0] : null;
          if (!file) {
            statusEl.textContent = "ファイルが選択されていません。";
            return;
          }

          statusEl.textContent = `${file.name} を読み込み中...`;
          try {
            const text = await file.text();
            const parsedDataset = parseCsvDataset(text);
            importedDataset = parsedDataset;
            importedDatasetName = file.name;
            datasetSource = "custom";
            setPointRangeFromDataset(importedDataset, { force: true });
            if (datasetStore && typeof datasetStore.save === "function") {
              datasetStore.save({
                name: importedDatasetName,
                dataset: importedDataset,
              });
            }
            storedSelection = datasetStore ? datasetStore.load() : storedSelection;
            refreshStoredDatasetButton();
            updateDatasetLabel();
            statusEl.textContent = `${file.name} を読み込みました。学習を開始します...`;
            await trainCurrentDataset();
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            statusEl.textContent = `CSVの読み込みに失敗しました: ${message}`;
            if (target) {
              target.value = "";
            }
          }
        });
      }

      if (useSavedDatasetButton) {
        useSavedDatasetButton.addEventListener("click", async () => {
          storedSelection = datasetStore ? datasetStore.load() : storedSelection;
          if (!storedSelection || !storedSelection.dataset) {
            refreshStoredDatasetButton();
            statusEl.textContent = "保存済みデータはありません。";
            return;
          }
          importedDataset = storedSelection.dataset;
          importedDatasetName = storedSelection.name || "インポートデータ";
          datasetSource = "custom";
          setPointRangeFromDataset(importedDataset, { force: true });
          updateDatasetLabel();
          statusEl.textContent = `${importedDatasetName} を読み込みました。学習を実行します...`;
          await trainCurrentDataset();
        });
      }

      if (resetDatasetButton) {
        resetDatasetButton.addEventListener("click", async () => {
          importedDataset = null;
          importedDatasetName = "";
          datasetSource = "dummy";
          setPointRangeFromDataset({ axis_bounds: DEFAULT_DUMMY_BOUNDS }, { force: true });
          if (fileInput) {
            fileInput.value = "";
          }
          if (datasetStore && typeof datasetStore.clear === "function") {
            datasetStore.clear();
          }
          storedSelection = null;
          refreshStoredDatasetButton();
          updateDatasetLabel();
          statusEl.textContent = "ダミーデータを読み込みました。学習を実行します...";
          await trainCurrentDataset();
        });
      }

      function renderTableRows(items) {
        if (!tableBody) {
          return;
        }
        tableBody.innerHTML = "";
        if (!items.length) {
          const row = document.createElement("tr");
          const cell = document.createElement("td");
          cell.colSpan = 5;
          cell.textContent = "結果はまだ計算されていません。";
          row.appendChild(cell);
          tableBody.appendChild(row);
          return;
        }
        items.forEach((item) => {
          const row = document.createElement("tr");
          row.innerHTML = `
            <td>${item.method}</td>
            <td>${item.smoothness_class}</td>
            <td>${Number(item.rmse).toFixed(4)}</td>
            <td>${Number(item.gradient_smoothness).toFixed(4)}</td>
            <td>${Number(item.laplacian_smoothness).toFixed(4)}</td>
          `;
          tableBody.appendChild(row);
        });
      }

      function buildDatasetProjectionTrace(dataset, axisLabel) {
        if (
          !dataset ||
          typeof dataset !== "object" ||
          !Array.isArray(dataset.points) ||
          !Array.isArray(dataset.values) ||
          dataset.points.length !== dataset.values.length
        ) {
          return null;
        }
        const axisMap = { x: 0, y: 1, z: 2 };
        const axisIndex = axisMap[axisLabel ? axisLabel.toLowerCase() : ""];
        if (!Number.isInteger(axisIndex)) {
          return null;
        }
        const xs = [];
        const ys = [];
        const customData = [];
        for (let i = 0; i < dataset.points.length; i += 1) {
          const point = dataset.points[i];
          const value = dataset.values[i];
          if (!Array.isArray(point) || point.length < 3) {
            continue;
          }
          const numericPoint = point.map((coord) => Number(coord));
          const axisValue = Number(point[axisIndex]);
          const numericValue = Number(value);
          if (
            numericPoint.some((coord) => !Number.isFinite(coord)) ||
            !Number.isFinite(axisValue) ||
            !Number.isFinite(numericValue)
          ) {
            continue;
          }
          xs.push(axisValue);
          ys.push(numericValue);
          customData.push([numericPoint[0], numericPoint[1], numericPoint[2], numericValue]);
        }
        if (!xs.length) {
          return null;
        }
        return {
          type: "scatter",
          mode: "markers",
          x: xs,
          y: ys,
          name: "元データ",
          customdata: customData,
          marker: {
            size: 7,
            color: "rgba(244,67,54,0.75)",
            line: { width: 1, color: "rgba(183,28,28,0.9)" },
          },
          hovertemplate:
            "x=%{customdata[0]:.4f}<br>y=%{customdata[1]:.4f}<br>z=%{customdata[2]:.4f}<br>value=%{customdata[3]:.4f}<extra>元データ</extra>",
        };
      }

      function formatModalPlaceholder(range, index) {
        if (!Array.isArray(range)) {
          return "自動";
        }
        const value = Number(range[index]);
        if (!Number.isFinite(value)) {
          return "自動";
        }
        return value.toFixed(4);
      }

      function resetModalInputs(rangeX, rangeY) {
        if (modalXAxisMin) {
          modalXAxisMin.value = "";
          modalXAxisMin.placeholder = formatModalPlaceholder(rangeX, 0);
        }
        if (modalXAxisMax) {
          modalXAxisMax.value = "";
          modalXAxisMax.placeholder = formatModalPlaceholder(rangeX, 1);
        }
        if (modalYAxisMin) {
          modalYAxisMin.value = "";
          modalYAxisMin.placeholder = formatModalPlaceholder(rangeY, 0);
        }
        if (modalYAxisMax) {
          modalYAxisMax.value = "";
          modalYAxisMax.placeholder = formatModalPlaceholder(rangeY, 1);
        }
      }

      function getModalRange(minInput, maxInput) {
        if (!minInput || !maxInput) {
          return null;
        }
        const min = Number.parseFloat(minInput.value);
        const max = Number.parseFloat(maxInput.value);
        if (Number.isFinite(min) && Number.isFinite(max) && min < max) {
          return [min, max];
        }
        return null;
      }

      function openLineSettingsModal() {
        if (lineSettingsBackdrop) {
          lineSettingsBackdrop.classList.add("open");
        }
        if (lineSettingsModal) {
          lineSettingsModal.classList.add("open");
          lineSettingsModal.setAttribute("aria-hidden", "false");
        }
      }

      function closeLineSettingsModal() {
        if (lineSettingsModal) {
          lineSettingsModal.classList.remove("open");
          lineSettingsModal.setAttribute("aria-hidden", "true");
        }
        if (lineSettingsBackdrop) {
          lineSettingsBackdrop.classList.remove("open");
        }
      }

      function renderModalPlot() {
        if (!modalContext || !plotModal || !modalPlotEl || typeof Plotly === "undefined") {
          return;
        }
        const layout = JSON.parse(JSON.stringify(modalContext.layout || {}));
        layout.height = modalPlotEl.clientHeight || 540;
        layout.margin = Object.assign({ l: 60, r: 30, t: 50, b: 50 }, layout.margin || {});
        const xRange = getModalRange(modalXAxisMin, modalXAxisMax);
        if (xRange) {
          layout.xaxis = Object.assign({}, layout.xaxis, {
            range: xRange,
            autorange: false,
          });
        }
        const yRange = getModalRange(modalYAxisMin, modalYAxisMax);
        if (yRange) {
          layout.yaxis = Object.assign({}, layout.yaxis, {
            range: yRange,
            autorange: false,
          });
        }
        Plotly.newPlot(modalPlotEl, cloneTraces(modalContext.traces), layout, plotlyConfig);
      }

      function openPlotModal(title, payload) {
        if (!plotModal || !modalPlotEl || !payload) {
          return;
        }
        modalContext = {
          title: title || "拡大表示",
          traces: payload.traces || [],
          layout: payload.modalLayout || payload.layout || {},
          defaultXRange: payload.defaultXRange || null,
          defaultYRange: payload.defaultYRange || null,
          axisLabels: payload.axisLabels || { x: "横軸", y: "縦軸" },
        };
        if (modalTitleEl) {
          modalTitleEl.textContent = modalContext.title;
        }
        if (modalXAxisLabelMin) {
          modalXAxisLabelMin.textContent = `${modalContext.axisLabels.x} 最小`;
        }
        if (modalXAxisLabelMax) {
          modalXAxisLabelMax.textContent = `${modalContext.axisLabels.x} 最大`;
        }
        if (modalYAxisLabelMin) {
          modalYAxisLabelMin.textContent = `${modalContext.axisLabels.y} 最小`;
        }
        if (modalYAxisLabelMax) {
          modalYAxisLabelMax.textContent = `${modalContext.axisLabels.y} 最大`;
        }
        resetModalInputs(modalContext.defaultXRange, modalContext.defaultYRange);
        if (modalBackdrop) {
          modalBackdrop.classList.add("open");
        }
        plotModal.classList.add("open");
        plotModal.setAttribute("aria-hidden", "false");
        renderModalPlot();
      }

      function closePlotModal() {
        if (plotModal) {
          plotModal.classList.remove("open");
          plotModal.setAttribute("aria-hidden", "true");
        }
        if (modalBackdrop) {
          modalBackdrop.classList.remove("open");
        }
        if (modalPlotEl && window.Plotly && typeof Plotly.purge === "function") {
          Plotly.purge(modalPlotEl);
        }
        resetModalInputs(null, null);
        modalContext = null;
      }

      function buildPlotPayload(item, datasetForDisplay) {
        if (!item) {
          return null;
        }
        const axisValues = Array.isArray(item.axis_values)
          ? item.axis_values.map((value) => Number(value))
          : [];
        const predictedValues = Array.isArray(item.predicted_values)
          ? item.predicted_values.map((value) => Number(value))
          : [];
        const datasetValues = Array.isArray(datasetForDisplay?.values)
          ? datasetForDisplay.values.map((value) => Number(value))
          : [];
        const datasetTrace = buildDatasetProjectionTrace(
          datasetForDisplay,
          item.varying_axis_label
        );
        const predictionTrace = {
          type: "scatter",
          mode: "lines+markers",
          x: axisValues,
          y: predictedValues,
          name: item.method,
          line: { width: 3 },
          marker: { size: 6 },
          hovertemplate: `${item.varying_axis_label}=%{x}<br>Value=%{y}<extra>${item.method}</extra>`,
        };
        const traces = datasetTrace ? [datasetTrace, predictionTrace] : [predictionTrace];
        const layout = {
          margin: { l: 40, r: 10, t: 10, b: 40 },
          xaxis: { title: `${item.varying_axis_label} 軸` },
          yaxis: { title: "予測値" },
          height: 320,
          showlegend: Boolean(datasetTrace),
          legend: { orientation: "h", y: -0.2 },
        };
        applyAxisRangesToLayout(layout, item, datasetForDisplay);
        const modalLayout = JSON.parse(JSON.stringify(layout));
        modalLayout.height = 540;
        modalLayout.margin = Object.assign({ l: 60, r: 30, t: 50, b: 50 }, modalLayout.margin || {});

        const computeDefaultRange = (values) => {
          const finite = filterFinite(values);
          if (!finite.length) {
            return null;
          }
          return [Math.min(...finite), Math.max(...finite)];
        };

        const axisLabels = {
          x: `${item.varying_axis_label} 軸`,
          y: "予測値",
        };
        const defaultXRange = computeDefaultRange(axisValues);
        const defaultYRange = computeDefaultRange(predictedValues.concat(datasetValues));

        return { traces, layout, modalLayout, axisLabels, defaultXRange, defaultYRange };
      }

      function renderLinePlots(results) {
        if (!plotsContainer) {
          return;
        }
        plotsContainer.innerHTML = "";
        if (!results.length) {
          plotsContainer.textContent = "ラインプロットを生成できませんでした。";
          return;
        }
        const datasetForDisplay = filterDatasetForDisplay(latestDataset);
        results.forEach((item) => {
          const card = document.createElement("section");
          card.className = "plot-card";
          const header = document.createElement("header");
          const title = document.createElement("h3");
          title.textContent = `${item.method} (${item.smoothness_class})`;
          title.classList.add("plot-title-button");
          title.setAttribute("role", "button");
          title.tabIndex = 0;
          header.appendChild(title);
          card.appendChild(header);

          const caption = document.createElement("p");
          const fixedText = Array.isArray(item.fixed_axes)
            ? item.fixed_axes
                .map((pair) => `${pair[0]}=${Number(pair[1]).toFixed(3)}`)
                .join(", ")
            : "";
          caption.style.margin = "0";
          caption.textContent = `${item.varying_axis_label}-軸方向のライン。固定: ${fixedText}`;
          card.appendChild(caption);

          const plotDiv = document.createElement("div");
          plotDiv.className = "plot-container";
          card.appendChild(plotDiv);
          plotsContainer.appendChild(card);

          const payload = buildPlotPayload(item, datasetForDisplay);
          if (!payload) {
            return;
          }
          Plotly.newPlot(
            plotDiv,
            cloneTraces(payload.traces),
            { ...payload.layout },
            plotlyConfig
          );
          const openModalHandler = () => {
            openPlotModal(title.textContent, payload);
          };
          title.addEventListener("click", openModalHandler);
          title.addEventListener("keydown", (event) => {
            if (event.key === "Enter" || event.key === " ") {
              event.preventDefault();
              openModalHandler();
            }
          });
        });
      }

      if (modalCloseButton) {
        modalCloseButton.addEventListener("click", closePlotModal);
      }
      if (modalBackdrop) {
        modalBackdrop.addEventListener("click", closePlotModal);
      }
      if (plotModal) {
        plotModal.addEventListener("click", (event) => {
          if (event.target === plotModal) {
            closePlotModal();
          }
        });
      }
      if (lineSettingsOpenButton) {
        lineSettingsOpenButton.addEventListener("click", openLineSettingsModal);
      }
      if (lineSettingsCloseButton) {
        lineSettingsCloseButton.addEventListener("click", closeLineSettingsModal);
      }
      if (lineSettingsBackdrop) {
        lineSettingsBackdrop.addEventListener("click", closeLineSettingsModal);
      }
      if (lineSettingsModal) {
        lineSettingsModal.addEventListener("click", (event) => {
          if (event.target === lineSettingsModal) {
            closeLineSettingsModal();
          }
        });
      }
      Object.values(pointRangeInputs).forEach((controls) => {
        if (!controls) {
          return;
        }
        [controls.min, controls.max]
          .filter(Boolean)
          .forEach((input) => {
            input.addEventListener("input", handlePointRangeInput);
            input.addEventListener("change", handlePointRangeInput);
          });
      });
      [modalXAxisMin, modalXAxisMax, modalYAxisMin, modalYAxisMax]
        .filter(Boolean)
        .forEach((input) => {
          input.addEventListener("input", renderModalPlot);
          input.addEventListener("change", renderModalPlot);
        });
      if (modalRangeResetButton) {
        modalRangeResetButton.addEventListener("click", () => {
          const xRange = modalContext ? modalContext.defaultXRange : null;
          const yRange = modalContext ? modalContext.defaultYRange : null;
          resetModalInputs(xRange, yRange);
          renderModalPlot();
        });
      }
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          closeLineSettingsModal();
          closePlotModal();
        }
      });

      async function runLinePrediction() {
        if (predicting) {
          return;
        }
        if (!sessionReady) {
          statusEl.textContent = "先にデータを読み込んでください。";
          return;
        }
        predicting = true;
        if (buttonEl) {
          buttonEl.disabled = true;
        }
        setAxisControlsDisabled(true);
        statusEl.textContent = "Python計算を実行中 (predictのみ)...";
        try {
          await pyodideReadyPromise;
          const axis = lineAxisSelect ? lineAxisSelect.value || "z" : "z";
          const fixedPayload = {};
          Object.entries(fixedInputs).forEach(([key, input]) => {
            if (!input || key === axis.toLowerCase()) {
              return;
            }
            const parsed = Number.parseFloat(input.value);
            if (Number.isFinite(parsed)) {
              fixedPayload[key] = parsed;
            }
          });
          const result = await callWorker("predictLine", {
            lineAxis: axis,
            fixedValues: fixedPayload,
            lineResolution: getLineResolutionPayload(),
          });
          latestLineResults = Array.isArray(result.line_results) ? result.line_results : [];
          latestSummaries = Array.isArray(result.summaries) ? result.summaries : [];
          latestDataset = result.dataset || null;
          setPointRangeFromDataset(latestDataset, { force: false });
          renderTableRows(latestSummaries);
          renderLinePlots(latestLineResults);
          applyFixedAxesFromResult(result.fixed_axes);
          if (lineAxisSelect && result.line_axis) {
            lineAxisSelect.value = result.line_axis;
            updateFixedControlsState();
          }
          if (lineResolutionInput && Number.isFinite(result.line_resolution)) {
            lineResolutionInput.value = String(result.line_resolution);
          }
          if (latestDataset && Array.isArray(latestDataset.axis_bounds)) {
            setFixedDefaultsFromBounds(latestDataset.axis_bounds);
          }
          if (result.skipped && result.skipped.length) {
            skippedContainer.hidden = false;
            skippedContainer.innerHTML =
              "<strong>スキップされた手法:</strong><ul>" +
              result.skipped
                .map((item) => `<li><code>${item[0]}</code>: ${item[1]}</li>`)
                .join("") +
              "</ul>";
          } else {
            skippedContainer.hidden = true;
            skippedContainer.textContent = "";
          }
          const datasetSource = result.dataset_source || (latestDataset && latestDataset.source);
          if (datasetSource === "custom") {
            const label = importedDatasetName || "インポートデータ";
            statusEl.textContent = `${label} でライン計算が完了しました。`;
          } else {
            statusEl.textContent = "ダミーデータでライン計算が完了しました。";
          }
        } catch (error) {
          console.error(error);
          const message = error instanceof Error ? error.message : String(error);
          statusEl.textContent = "ライン計算に失敗しました: " + message;
        } finally {
          predicting = false;
          if (buttonEl) {
            buttonEl.disabled = !sessionReady;
          }
          setAxisControlsDisabled(!sessionReady);
        }
      }

      async function trainCurrentDataset() {
        if (datasetSource === "none") {
          statusEl.textContent = "先にデータを読み込んでください。";
          return;
        }
        if (trainingPromise) {
          await trainingPromise;
          return trainCurrentDataset();
        }
        trainingPromise = (async () => {
          sessionReady = false;
          if (buttonEl) {
            buttonEl.disabled = true;
          }
          setAxisControlsDisabled(true);
          clearVisualizations();
          const label = currentDatasetLabel();
          statusEl.textContent = `${label} を用いて学習中...`;
          try {
            await pyodideReadyPromise;
            await callWorker("fit", {
              dataset: datasetSource === "custom" ? importedDataset : null,
            });
            sessionReady = true;
            statusEl.textContent = `${label} の学習が完了しました。ラインを計算ボタンでpredictを実行してください。`;
          } catch (error) {
            console.error(error);
            const message = error instanceof Error ? error.message : String(error);
            statusEl.textContent = "学習に失敗しました: " + message;
            sessionReady = false;
          } finally {
            if (!sessionReady && buttonEl) {
              buttonEl.disabled = true;
            }
            if (sessionReady && buttonEl && !predicting) {
              buttonEl.disabled = false;
            }
            setAxisControlsDisabled(!sessionReady);
            trainingPromise = null;
          }
        })();
        await trainingPromise;
      }


      if (buttonEl) {
        buttonEl.addEventListener("click", () => runLinePrediction());
      }
      if (lineAxisSelect) {
        lineAxisSelect.addEventListener("change", () => {
          updateFixedControlsState();
        });
      }
    </script>
  </body>
</html>
